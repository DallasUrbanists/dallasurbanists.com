---
layout: stlc-default
---
<style>
    .event-item {
        flex-direction: row;
        display: flex;
        position: relative;
        text-overflow: ellipsis;
        /* background-color: var(--strongtowns-sand); */
        margin-bottom: 5px;
        height: fit-content;
        width: 100%;
        overflow: hidden;
        transition: all 0.2s ease;
        max-height: 175px;

        .event-column {
            flex-grow: 1;
            flex-shrink: 1;
            padding: 1rem;

            p,
            a {
                word-break: break-word;
            }

            h2 {
                font-size: 1rem;
                margin-bottom: 0;
            }

        }

        .date-column {
            flex-grow: 0;
        }

        .details-column {
            flex-grow: 1;
            width: calc(100% - 7rem);
            background-color: var(--strongtowns-sand);

            .event-notes,
            .event-notes-preview {
                line-height: 1.25em;
                height: 1em;
            }

            .event-notes-preview {
                opacity: 0.6;
            }

            .event-notes-preview:hover {
                opacity: 1;
            }

            .event-notes-preview {
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
                display: inline;
            }

            .event-notes {
                display: none;
            }
        }

        .event-location {
            line-height: 1em;
        }
    }



    .event-item.expanded {
        max-height: none;
        border: solid 1px #eee;

        .event-column.details-column {
            .event-notes {
                display: block;
                height: auto;
                white-space: normal;
            }

            .event-notes-preview {
                display: none;
            }
        }
    }

    .event-item:hover {
        transition: all 0.1s ease;
        filter: saturate(5);
        border-color: black;
        cursor: pointer;
    }

    /* .event-item:after {
        content: " ";
        background-image: linear-gradient(to bottom, transparent 0%, white 80%);
        position: absolute;
        display: block;
        bottom: 0;
        right: 0;
        width: 100%;
        height: 2rem;
    } */

    .event-item .event-column p {
        font-weight: normal;
    }

    .event-item .event-column b,
    .event-item .event-column strong {
        font-weight: 600;
        color: #555;
    }

    .horizontal-tabnav a {
        display: inline-block;
        padding: 1rem;
        text-decoration: none;
        font-weight: bold;
        border-bottom: none;
        color: white;
    }

    .horizontal-tabnav a:hover {
        cursor: pointer;
        background-color: rgba(255, 255, 255, 0.25);
    }

    .horizontal-tabnav a.active,
    .horizontal-tabnav a.active:hover {
        color: black;
        background-color: white;
        cursor: default;
    }

    #event-feed h1 {
        font-size: 2rem;
        text-transform: uppercase;
        font-weight: lighter;
        color: #888;
        padding: 1rem;
        padding-bottom: 0;
    }

    .event-item .event-column:last-child p {
        opacity: 0.9;
    }

    .event-item.expanded .event-column:last-child p {
        opacity: 1;
    }

    .event-date {
        font-size: 1rem;
        margin-bottom: 0rem;
        line-height: 1rem;
        font-family: monospace;
        text-align: right;
        width: 7em;

        .weekday,
        .time,
        .time.end {
            display: block;
        }

        .date {
            font-weight: bold;
        }
    }


    .event-item.duplicate-date {
        margin-top: -5px;

        .event-date .date,
        .event-date .weekday {
            display: none;
        }
    }

    @media (max-width: 360px) {
        .event-item {
            flex-direction: column;
            background-color: var(--strongtowns-sand);
            margin-bottom: 1rem;

            .details-column {
                width: 100%;
            }

            .event-column.details-column {
                padding-top: 0;
            }
        }

        .event-item .event-column:last-child {
            padding-top: 0;
        }

        .event-item .event-column:first-child {
            width: 100%;
            min-width: auto;
            padding-bottom: 0;
        }

        .event-date {
            width: 100%;
            text-align: left;

            .weekday,
            .time,
            .time.end {
                display: inline-block;
                margin-left: 1ch;
            }

            .date {
                font-weight: normal;
            }
        }

        .event-item.duplicate-date {
            margin-top: 0;

            .event-date .date,
            .event-date .weekday {
                display: inline-block;
            }
        }
    }
</style>
<section class="bg-navy">
    <div class="body-wrapper padded" style="width: 100%;">
        <h1 style="margin-bottom: 0.5rem;">Community Calendar</h1>
        <p style="margin-bottom: 0; color: #AAA; line-height: 1.5rem;">This calendar curates events from local
            residents,
            businesses, nonprofits, and government agencies. Find social gatherings, civic meetings, and volunteer
            opportunities here. Suggestions are welcome at <a
                href="mailto:contact@dallasurbanists.org">contact@dallasurbanists.org</a>.</p>
    </div>
</section>
<section class="bg-navy">
    <div class="body-wrapper">
        <div class="horizontal-tabnav">
            <a href="#" id="upcoming-link">Upcoming Events</a>
            <a href="#" id="past-link">Past Events</a>
        </div>
    </div>
</section>
<section class="bg-white" style="padding-top: 1rem;">
    <div class="body-wrapper">
        <div id="event-feed"></div>
    </div>
</section>

<script>
    // Teamup API details
    const teamupAPIToken = 'fa68b6f0d704a55141e7ba70b0497ddec7852b815ce24df37d8c19482f308f01';
    const teamupAPIBaseURL = 'https://api.teamup.com/ksmwn2f7yyqnumzf3r/';

    // The HTML element where events will be displayed
    const eventFeed = document.getElementById('event-feed');

    // Cache keys based on current date and time to avoid hitting API more than once per minute
    const upcomingCacheKey = 'upcoming' + cacheKey();
    const pastCacheKey = 'past' + cacheKey();
    function cacheKey() {
        const d = new Date();
        const Y = d.getFullYear();
        const M = String(d.getMonth() + 1).padStart(2, '0');
        const D = String(d.getDate()).padStart(2, '0');
        const h = String(d.getHours()).padStart(2, '0');
        const m = String(d.getMinutes()).padStart(2, '0');
        return `${Y}${M}${D}${h}${m}`;
    }

    // Determine mode from URL parameter
    let mode = 'upcoming';
    const setMode = (newMode) => mode = newMode;
    const urlParams = new URLSearchParams(window.location.search || '');
    if ((urlParams.get('mode') || '').toLowerCase() === 'past') {
        mode = 'past';
    }

    document.getElementById('upcoming-link').addEventListener('click', (e) => {
        e.preventDefault();
        setMode('upcoming');
        const u = new URL(window.location.href);
        u.searchParams.set('mode', 'upcoming');
        history.replaceState(null, '', u.toString());
        findEvents();
    });
    document.getElementById('past-link').addEventListener('click', (e) => {
        e.preventDefault();
        setMode('past');
        const u = new URL(window.location.href);
        u.searchParams.set('mode', 'past');
        history.replaceState(null, '', u.toString());
        findEvents();
    });

    let foundEvents = [];

    function findEvents() {
        let storedEvents = localStorage.getItem(mode === 'upcoming' ? upcomingCacheKey : pastCacheKey);
        if (storedEvents) {
            console.log(`Using cached ${mode} events (${mode === 'upcoming' ? upcomingCacheKey : pastCacheKey})`);
            foundEvents = JSON.parse(storedEvents);
            populateEvents();
        } else {
            console.log(`Using fresh ${mode} events`);
            fetchEvents(mode).then((results) => {
                const useKey = mode === 'upcoming' ? upcomingCacheKey : pastCacheKey;
                foundEvents = results;
                // Clear out old cache entries
                Object.keys(localStorage).forEach(key => {
                    if (typeof key === 'string' && key.startsWith(mode)) {
                        localStorage.removeItem(key);
                    }
                });
                localStorage.setItem(useKey, JSON.stringify(foundEvents));
                populateEvents();
            });
        }
    }

    findEvents();

    function toggleNavLinks() {
        document.querySelectorAll('.horizontal-tabnav a').forEach((link) => link.classList.remove('active'));
        const activate = (id) => document.getElementById(id).classList.add('active');
        switch (mode) {
            case 'upcoming':
                activate('upcoming-link');
                break;
            case 'past':
                activate('past-link');
                break;
        }
    }

    function populateEvents() {
        eventFeed.innerHTML = '';
        if (mode === 'upcoming') {
            document.getElementById('upcoming-link').classList.add('active');
            document.getElementById('past-link').classList.remove('active');
            foundEvents.sort((a, b) => new Date(a.start_dt) - new Date(b.start_dt));
        } else {
            document.getElementById('upcoming-link').classList.add('active');
            document.getElementById('past-link').classList.remove('active');
            foundEvents.sort((a, b) => new Date(b.start_dt) - new Date(a.start_dt));
        }

        toggleNavLinks();

        let printedTodayHeader = false;
        let printedThisWeekHeader = false;
        const printedMonths = [];

        const isToday = (date) => {
            const today = new Date();
            return date.getDate() === today.getDate() &&
                date.getMonth() === today.getMonth() &&
                date.getFullYear() === today.getFullYear();
        };
        const isThisWeek = (date) => {
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            const weekFromToday = new Date(today);
            weekFromToday.setDate(weekFromToday.getDate() + 6);
            return date >= tomorrow && date <= weekFromToday;
        };

        let prior = null;
        foundEvents.forEach(event => {
            const startDate = new Date(event.start_dt);

            // Wraps around entire event item
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event-item';

            // Three column layout
            const column1 = document.createElement('div');
            const column2 = document.createElement('div');
            const column3 = document.createElement('div');
            column1.className = 'event-column date-column';
            column2.className = 'event-column details-column';
            column3.className = 'event-column';

            // Contents of first column
            const dateDiv = document.createElement('div');
            const dateTransform = transformDate(event);
            const priorTransform = prior ? transformDate(prior) : null;
            dateDiv.className = 'event-date';
            dateDiv.innerHTML = dateTransform.string;
            column1.appendChild(dateDiv);
            if (dateTransform.datePortion === priorTransform?.datePortion) {
                eventDiv.classList.add('duplicate-date');
            }

            // Contents of second column
            const titleH2 = document.createElement('h2');
            const whoSpan = document.createElement('span');
            const locationDiv = document.createElement('div');
            const notesDiv = document.createElement('div');
            const previewDiv = document.createElement('div');
            locationDiv.className = 'event-location';
            notesDiv.className = 'event-notes';
            previewDiv.className = 'event-notes-preview';
            column2.appendChild(titleH2);
            titleH2.textContent = event.title;
            if (event.who && event.who.trim() !== '') {
                whoSpan.innerHTML = ` â€” ${transformWho(event.who)}`;
                titleH2.appendChild(whoSpan);
            }
            if (event.location && event.location.trim() !== '') {
                locationDiv.textContent = transformLocation(event.location);
                column2.appendChild(locationDiv);
            }
            if (event.notes && event.notes.trim() !== '') {
                notesDiv.innerHTML = transformNotes(event.notes);
                previewDiv.innerHTML = compressedNotes(event.notes);
                column2.appendChild(notesDiv);
                column2.appendChild(previewDiv);
            }

            // Contents of third column
            const descriptionP = document.createElement('p');
            //column3.appendChild(descriptionP);
            descriptionP.innerHTML = event.notes || '';

            // Display appropriate header
            if (mode === 'upcoming') {
                if (isToday(startDate) && !printedTodayHeader) {
                    const todayHeader = document.createElement('h1');
                    todayHeader.textContent = 'Today';
                    eventFeed.appendChild(todayHeader);
                    printedTodayHeader = true;
                } else if (isThisWeek(startDate) && !printedThisWeekHeader) {
                    const thisWeekHeader = document.createElement('h1');
                    thisWeekHeader.textContent = 'This Week';
                    eventFeed.appendChild(thisWeekHeader);
                    printedThisWeekHeader = true;
                } else if (!isToday(startDate) && !isThisWeek(startDate)) {
                    const monthYear = startDate.toLocaleDateString("en-US", { year: 'numeric', month: 'long' });
                    if (!printedMonths.includes(monthYear)) {
                        const monthHeader = document.createElement('h1');
                        monthHeader.textContent = monthYear;
                        eventFeed.appendChild(monthHeader);
                        printedMonths.push(monthYear);
                    }
                }
            }

            // Put everything together
            eventDiv.appendChild(column1);
            eventDiv.appendChild(column2);
            eventFeed.appendChild(eventDiv);

            prior = event;
        });

        document.querySelectorAll('.event-item').forEach((item) => item.addEventListener('click', (e) => {
            e.currentTarget.classList.toggle('expanded');
        }));
    }

    function transformWho(original) {
        switch (original.toLowerCase()) {
            case 'data':
                return 'Dallas Area Transit Alliance';
            default:
                return original;
        }
    }
    function transformLocation(original) {
        const parts = original
            .trim()
            .split(',')
            .map(part => {
                part = part.trim();
                if (part.startsWith('TX ')) {
                    part = part.replace('TX ', '');
                }
                return part;
            })
            .filter(part => part.length > 0) // remove empty parts
            .filter((part, index, arr) => arr.indexOf(part) === index) // remove duplicates
            .filter(part => {
                const upper = part.toUpperCase().trim();
                if (upper === 'TX') return false;
                if (upper === 'USA') return false;
                return true;
            });
        if (parts.length > 1) {
            return parts[0] + ', ' + parts.slice(1).join(' ');
        }
        return parts[0];
    }
    function transformNotes(original) {
        let transformed = original;
        // Convert line breaks to <br> tags
        // transformed = transformed.replace(/\n/g, '<br>');
        return transformed;
    }
    function compressedNotes(original) {
        let transformed = original;
        // Remove line breaks
        transformed = transformed.replaceAll(/\n/g, ' ');
        transformed = transformed.replaceAll('<br>', ' ');
        transformed = transformed.replaceAll('<br />', ' ');
        transformed = transformed.replaceAll('<p>', ' ');
        transformed = transformed.replaceAll('<P>', ' ');
        transformed = transformed.replaceAll('</p>', ' ');
        transformed = transformed.replaceAll('</P>', ' ');
        return transformed;
    }
    function transformDate(event) {
        const startDate = new Date(event.start_dt);
        const endDate = new Date(event.end_dt);
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const weekday = weekdays[startDate.getDay()];
        //const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const month = months[startDate.getMonth()];
        const day = startDate.getDate();
        const hour24 = startDate.getHours();
        const hour = hour24 > 12 ? hour24 - 12 : (hour24 === 0 ? 12 : hour24);
        const minute = String(startDate.getMinutes()).padStart(2, '0');
        const ampm = hour24 >= 12 ? 'PM' : 'AM';

        let datePortion = `<span class='date'>${month} ${day}</span>`;
        let weekPortion = `<span class='weekday'>${weekday}</span>`;
        let timePortion = `<span class='time'>${hour}:${minute} ${ampm}</span>`;
        let duration = 0;
        let isMultiDay = false;

        if (event.end_dt && event.end_dt !== event.start_dt) {
            const endMonth = months[endDate.getMonth()];
            const endDay = endDate.getDate();
            if (`${endMonth} ${endDay}` !== `${month} ${day}`) {
                isMultiDay = true;
                weekPortion = `<span class='weekday'>${weekday} - ${weekdays[endDate.getDay()]}</span>`;
                timePortion = `<span class='time'>Starts ${hour}:${minute} ${ampm}</span>`;
            } else {
                duration = (endDate - startDate) / (1000 * 60); // duration in minutes
                if (duration > 60) {
                    // Show end time if over an hour
                    const endHour24 = endDate.getHours();
                    const endHour = endHour24 > 12 ? endHour24 - 12 : (endHour24 === 0 ? 12 : endHour24);
                    const endMinute = String(endDate.getMinutes()).padStart(2, '0');
                    const endAmpm = endHour24 >= 12 ? 'PM' : 'AM';

                    //const startTimeString = `${hour}:${minute}`;
                    const endTimeString = `${endHour}:${endMinute} ${endAmpm}`;

                    timePortion = timePortion + `<span class='time end'> to ${endTimeString}</span>`;
                    // timePortion = timePortion + ` <span class='time'>to ${endHour}:${endMinute} ${endAmpm}</span>`;
                } else if (duration < 60 && duration >= 15) {
                    // Show duration in minutes
                    timePortion = timePortion + `<span class='time end'>${duration} minutes</span>`;
                } else if (duration === 60) {
                    // Show "1 hour"
                    timePortion = timePortion + `<span class='time end'>1 hour</span>`;
                }
            }
        }
        if (event.all_day === true) {
            timePortion = `<span class='time'>ALL DAY</span>`;
        }

        return {
            datePortion,
            string: datePortion + weekPortion + timePortion,
        };
    }

    async function fetchEvents(mode) {
        let startDate = new Date();
        let endDate = new Date(startDate);
        let sortFunction;
        const format = (date) => date.toISOString().split('T')[0];
        if (mode === 'upcoming') {
            endDate.setMonth(endDate.getMonth() + 6);
            sortFunction = (a, b) => new Date(a.start_dt) - new Date(b.start_dt);
        } else {
            startDate.setMonth(startDate.getMonth() - 6);
            endDate.setDate(endDate.getDate() - 1);
            sortFunction = (a, b) => new Date(b.start_dt) - new Date(a.start_dt);
        }
        const params = new URLSearchParams({ 'startDate': format(startDate), 'endDate': format(endDate) });
        try {
            const response = await fetch(
                `${teamupAPIBaseURL}events?${params}`,
                {
                    method: "GET", headers: { "Teamup-Token": teamupAPIToken }
                });
            if (!response.ok) {
                throw new Error(`Response status: ${response.status}`);
            }
            const result = await response.json();
            const found = result.events;
            found.sort(sortFunction);

            // limit to the first 100 items
            return found.slice(0, 100);
        } catch (error) {
            console.error(error.message);
        }
        return [];
    }
</script>